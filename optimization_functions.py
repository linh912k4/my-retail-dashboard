# -*- coding: utf-8 -*-
"""optimization_functions

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rsbuv79Zr8A8cy4KcyVFAMaE39mk7U29
"""

import pandas as pd
import pulp
import io

def run_optimization(
    store_info_path='store_info_data_2023_2024_updated.csv', # Đổi thành 'data/'
    trans_info_path='transaction_data_2023_2024_updated - transaction_data_2023_2024_updated.csv', # Đổi thành 'data/'
    st=None
):
    """
    Runs the stock optimization problem using PuLP.
    Prints the results and saves to CSV.
    """
    if st is None:
        raise ValueError("Streamlit object (st) must be provided.")

    st.subheader("Tối ưu hóa Vận chuyển Tồn kho")
    st.write("---")

    store_info = pd.read_csv(store_info_path)
    trans_info = pd.read_csv(trans_info_path)

    products = trans_info['Product_ID'].unique()
    warehouse_stock = {p: 1000 for p in products} # Giả sử kho trung tâm có 1000 mỗi sản phẩm
    stores = trans_info['Store_ID'].unique()

    distance = {}
    for _, row in store_info.iterrows():
        if pd.notna(row['Related_Store_ID']):
            distance[(row['Store_ID'], row['Related_Store_ID'])] = row['Distance']
            distance[(row['Related_Store_ID'], row['Store_ID'])] = row['Distance']

    stock_level = {}
    reorder_threshold = {}
    for _, row in trans_info.iterrows():
        stock_level[(row['Store_ID'], row['Product_ID'])] = row['Stock_Level']
        reorder_threshold[(row['Store_ID'], row['Product_ID'])] = row['Reorder_Threshold']

    prob = pulp.LpProblem("Stock_Optimization", pulp.LpMinimize)

    x = pulp.LpVariable.dicts("x", [(i, j, p) for i in stores for j in stores for p in products if i != j and (i, j) in distance], lowBound=0, cat='Integer')
    y = pulp.LpVariable.dicts("y", [(j, p) for j in stores for p in products], lowBound=0, cat='Integer')

    warehouse_distances = {}
    for _, row in store_info.iterrows():
        if row['Related_Store_ID'] == 'Warehouse':
            warehouse_distances[row['Store_ID']] = row['Distance']

    # Objective function
    prob += pulp.lpSum([distance[(i, j)] * x[(i, j, p)] for i in stores for j in stores for p in products if i != j and (i, j) in distance]) + \
            pulp.lpSum([warehouse_distances[j] * y[(j, p)] for j in stores for p in products if j in warehouse_distances])

    # Constraints
    for j in stores:
        for p in products:
            current_stock = stock_level.get((j, p), 0)
            threshold = reorder_threshold.get((j, p), 10)

            prob += current_stock + pulp.lpSum([x[(i, j, p)] for i in stores if i != j and (i, j) in distance]) + \
                    y[(j, p)] - pulp.lpSum([x[(j, k, p)] for k in stores if j != k and (j, k) in distance]) >= threshold

            prob += current_stock - pulp.lpSum([x[(j, k, p)] for k in stores if j != k and (j, k) in distance]) >= 0

    for p in products:
        prob += warehouse_stock[p] - pulp.lpSum([y[(j, p)] for j in stores]) >= 0

    with st.spinner('Đang giải bài toán tối ưu hóa tồn kho...'):
        prob.solve()
    st.success("Bài toán tối ưu hóa đã được giải quyết.")

    st.write(f"**Trạng thái giải:** {pulp.LpStatus[prob.status]}")

    result_data = []

    # From Warehouse
    for (j, p), var in y.items():
        if var.varValue > 0:
            distance_val = warehouse_distances.get(j, 0)
            result_data.append({
                'Type': 'From Warehouse',
                'From': 'Warehouse',
                'To': j,
                'Product_ID': p,
                'Quantity': var.varValue,
                'Distance': distance_val
            })

    # Between Stores
    for (i, j, p), var in x.items():
        if var.varValue > 0:
            distance_val = distance.get((i, j), 0)
            result_data.append({
                'Type': 'Between Stores',
                'From': i,
                'To': j,
                'Product_ID': p,
                'Quantity': var.varValue,
                'Distance': distance_val
            })

    df_result = pd.DataFrame(result_data)

    st.write("#### Kết quả vận chuyển tối ưu:")
    if not df_result.empty:
        st.dataframe(df_result)
        st.write(f"**Tổng quãng đường vận chuyển tối thiểu:** {pulp.value(prob.objective):.2f}")
    else:
        st.write("Không có hành động vận chuyển nào được đề xuất (hệ thống có thể đã đủ tồn kho).")

    # Optionally save to CSV for download
    csv_buffer = io.StringIO()
    df_result.to_csv(csv_buffer, index=False)
    st.download_button(
        label="Tải kết quả vận chuyển (.csv)",
        data=csv_buffer.getvalue(),
        file_name='transportation_result.csv',
        mime='text/csv',
    )
    st.write("---")
